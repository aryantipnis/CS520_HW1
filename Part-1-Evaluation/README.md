## Part 1: Prompt Design & Code Generation

Below is a clear explanation of **what each file contains** and how the pieces fit together.  

Each `problem_X.py` file follows the same structure and contains 4 candidate solutions generated by two LLMs with two different prompts each. Each problem file also contains the test-cases used for evaluation and the correct solution.

---

### The prompts used are:  

**Prompt 1: Chain of Thought**

*“Think step-by-step to solve this problem then write the Python code to solve this problem. [Pasted problem description here]”*

**Prompt 2: Self Planning**

*“Before writing code, outline a plan that describes what functions you will implement and how they will interact. Then, based on your plan, write a python code for this problem. [Pasted problem description here]”*


---
### File Contents: `problem_X.py` (for X = 1..10) 


1. **Problem description**
   - A short description of the programming task (copied from the dataset or my own problem text for problem 10).
   - Example input/output examples and constraints.

2. **Generated output and code solutions (4 total)**  
   Each file includes four functions — two LLM families × two prompts:
   - `solution1(...)`  
     - LLM Model GPT-4 using **Prompt 1: Chain of Thought (CoT)**  
   - `solution2(...)`  
     - LLM Model GPT-4 using **Prompt 2: Self Planning**  
   - `solution3(...)`  
     - LLM Model Claude Sonnet 4.5 using **Prompt 1: Chain of Thought (CoT)**  
   - `solution4(...)`  
     - LLM Model Claude Sonnet 4.5 using **Prompt 2: Self Planning**  

    The raw code is preserved exactly as produced by the LLM (without comments).

3. **Correct Solution**
   - This solution has been copied from the dataset and passes all the given test cases. 

4. **Test cases**
   - A list of test inputs and expected outputs used for local evaluation.  
   - Tests include:
     - Happy-path / typical cases
     - Edge/boundary cases

---

### To run these files: 

Run the command `python Problem_X.py` where `X = 1 to 10` in the terminal, the problem number you want to run. This command will run all 4 generated solutions over the given test cases and print a message if they are successful or give an error if they fail. 